#!/usr/bin/python3
import sys
import numpy as np
import os
import __main__ as main


import pyProbeParticle                as PPU     
from   pyProbeParticle            import basUtils
from   pyProbeParticle            import elements   
import pyProbeParticle.GridUtils      as GU
#import pyProbeParticle.core          as PPC
import pyProbeParticle.HighLevel      as PPH
import pyProbeParticle.fieldFFT       as fFFT

HELP_MSG="""Use this program in the following way:
"""+os.path.basename(main.__file__) +""" -i <filename> [ --sigma <value> ]

Supported file formats are:
   * cube
   * xsf """

from optparse import OptionParser

parser = OptionParser()
parser.add_option( "-i", "--input", action="store", type="string", help="format of input file")
parser.add_option( "-t", "--tip",   action="store", type="string", help="tip model (multipole)"      , default='None')
parser.add_option( "-w", "--sigma", action="store", type="float",  help="gaussian width for convolution in Electrostatics [Angstroem]", default=-1.0)
parser.add_option( "--npy" , action="store_true"  , help="load and save fields in npy instead of xsf", default=False)
parser.add_option( "--tip_base",    action="store", type="string", help="tip_base model (multipole)" , default='None')
parser.add_option( "--KPFM",        action="store", type="string", help="KPFM model True/False"      , default='None')
parser.add_option( "--prolongez",   action="store", type="float",  help="prolonge cell in z (where,how) [A]", nargs=2, default=[-1,-1])
(options, args) = parser.parse_args()

print(options)
if options.npy:
    data_format ="npy"
else:
    data_format ="xsf"

if options.input==None:
    sys.exit("ERROR!!! Please, specify the input file with the '-i' option \n\n"+HELP_MSG)

print(" >> OVEWRITING SETTINGS by params.ini  ")
PPU.loadParams( 'params.ini' )

print(" ========= get electrostatic forcefiled from hartree ")

# TODO with time implement reading a hartree potential generated by different software
print(" loading Hartree potential from disk ")
if(options.input.lower().endswith(".xsf") ):
    print("Use loadXSF")
    V, lvec, nDim, head = GU.loadXSF(options.input)
elif(options.input.lower().endswith(".cube") ):
    print("Use loadCUBE")
    V, lvec, nDim, head = GU.loadCUBE(options.input)
    V*=27.211396132
else:
    sys.exit("ERROR!!! Unknown format of the input file\n\n"+HELP_MSG)


if options.prolongez[0] > 0.0:
    V=np.array(V)
    assert options.prolongez[0] < lvec[3,2] , "prolongez is higher than height of the cell"
    print("prolonging_z at height %f by appr. %f" %(options.prolongez[0],options.prolongez[1]))
    #print "Debug: nDim", nDim
    nz = int(nDim[0]*options.prolongez[0]/lvec[3,2])
    nn = int(nDim[0]*options.prolongez[1]/lvec[3,2])
    print("this means adding %i new z-voxels in between above z-voxel %i" %(nn, nz))
    lvec[3,2] = lvec[3,2]+nn*lvec[3,2]/nDim[0];
    nDim[0]=nDim[0]+nn;
    print("lvec:", lvec)
    print("nDim:", nDim)
    Vnew = np.zeros((nDim[0],nDim[1],nDim[2]))
    print(V.shape)
    print(Vnew.shape)
    for i in range(nDim[0]):
        if i < nz: # i starts from 0
            Vnew[i] = V[i]
        elif i >= nz+nn:
            Vnew[i] = V[i-nn]
        else:
            for j in range(nDim[1]):
                for k in range(nDim[2]):
                    Vnew[i,j,k] = (i-nz)*(V[nz-1,j,k]-V[nz,j,k])/nn+V[nz,j,k]
    V = Vnew;
    GU.save_scal_field("V_prolonged",Vnew,lvec,data_format=data_format)

rho = None
sigma = options.sigma if ( options.sigma > 0.0) else PPU.params['sigma']
multipole = None

if (options.tip.endswith(".xsf") or options.tip.endswith(".cube") ) :
    rho, lvec_tip, nDim_tip, tiphead = GU.loadXSF(options.tip) if (options.tip.endswith(".xsf")) else GU.loadCUBE(options.tip)
    if (nDim_tip != nDim):
        sys.exit("Error: Input file for tip charge density has been specified, but the dimensions are incompatible with the Hartree potential file!")    
else:
    multipole = {options.tip:1.0} if ( options.tip in {'s','px','py','pz','dx2','dy2','dz2','dxy','dxz','dyz'} ) else {PPU.params['tip']:1.0}

print(" computing convolution with tip by FFT ")
Fel_x,Fel_y,Fel_z = fFFT.potential2forces(V, lvec, nDim, rho=rho, sigma = sigma, multipole = multipole); del rho, multipole;
FFel = GU.packVecGrid(Fel_x,Fel_y,Fel_z); del Fel_x,Fel_y,Fel_z;

print(" saving electrostatic forcefield ")
GU.save_vec_field("FFel",FFel,lvec,data_format=data_format); del FFel;

tip_base = options.tip_base if ( options.tip_base is not 'None') else PPU.params["tip_base"][0]
KPFM = options.KPFM if ( options.KPFM is not 'None') else PPU.params["KPFM"][0]

if ((tip_base  != 'None') and (tip_base != None)):
    print(" CALCULATING z-force-field for tip_base mono-/multipole ")
    print(" chosen tip_base multipole: ", tip_base)
    print(" computing convolution with tip_base by FFT ")
    rho = None
    Fel_x,Fel_y,Fel_z = fFFT.potential2forces(V, lvec, nDim, rho=rho, sigma = sigma, multipole = {tip_base:1.0} ); del rho;
    #FFel = GU.packVecGrid(Fel_x,Fel_y,Fel_z)
    print(" saving z-electrostatic forcefield of the tip_base")
    GU.save_scal_field("FFel_tip",Fel_z,lvec,data_format=data_format)
    del Fel_x,Fel_y,Fel_z;
    
if ((KPFM  != 'None') and (KPFM != None)):
    sigma=float(PPU.params["KPFM"][1])
    multipole={'s':1.0}
    print (" CALCULATING z-force-field for KPFM calculations")
    print (" chosen KPFM electrostatics is fixed to ",multipole," and only 'z' component; sigma is: " , sigma)
    print (" computing convolution with tip_base by FFT ")
    rho = None
    Fel_x,Fel_y,Fel_z = fFFT.potential2forces(V, lvec, nDim, rho=rho, sigma = sigma, multipole = multipole ); del Fel_x,Fel_y,rho;
    #FFel = GU.packVecGrid(Fel_x,Fel_y,Fel_z)
    print (" saving z-electrostatic forcefield for KPFM calculations")
    GU.save_scal_field("FFel_kpfm",Fel_z,lvec,data_format=data_format)
    del Fel_z, V;
else:
    del V;
